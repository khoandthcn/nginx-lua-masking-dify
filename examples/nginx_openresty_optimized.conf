# OpenResty Optimized Configuration for Masking Plugin v2.1
# Tuned for high performance and reliability

worker_processes auto;
worker_cpu_affinity auto;
worker_rlimit_nofile 65535;

error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 4096;
    use epoll;
    multi_accept on;
    accept_mutex off;
}

http {
    # Basic settings
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    keepalive_requests 1000;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    
    # Lua configuration optimized for OpenResty
    lua_package_path "/opt/nginx-lua-masking/lib/?.lua;/usr/local/openresty/lualib/?.lua;;";
    lua_package_cpath "/usr/local/openresty/lualib/?.so;;";
    
    # Shared dictionaries with optimized sizes
    lua_shared_dict masking_mappings 50m;
    lua_shared_dict masking_stats 10m;
    lua_shared_dict masking_cache 20m;
    lua_shared_dict masking_config 5m;
    
    # Lua settings for performance
    lua_code_cache on;
    lua_check_client_abort on;
    lua_socket_pool_size 30;
    lua_socket_keepalive_timeout 60s;
    lua_socket_connect_timeout 5s;
    lua_socket_send_timeout 5s;
    lua_socket_read_timeout 5s;
    
    # Initialize plugin with optimizations
    init_by_lua_block {
        -- Set up global error handling
        local function handle_error(err)
            ngx.log(ngx.ERR, "[MASKING-PLUGIN] Initialization error: " .. tostring(err))
            return false
        end
        
        local ok, err = xpcall(function()
            -- Load optimized modules
            local utils = require("utils")
            local pattern_matcher = require("pattern_matcher")
            local json_processor = require("json_processor")
            local masking_plugin = require("masking_plugin")
            
            -- Initialize shared data
            ngx.shared.masking_config:set("version", "2.1.0")
            ngx.shared.masking_config:set("initialized", "true")
            ngx.shared.masking_config:set("start_time", ngx.time())
            
            -- Pre-compile patterns for better performance
            local pm = pattern_matcher.new()
            ngx.shared.masking_config:set("patterns_loaded", #pm.patterns)
            
            ngx.log(ngx.ERR, "[MASKING-PLUGIN] v2.1.0 initialized successfully with " .. #pm.patterns .. " patterns")
            
        end, handle_error)
        
        if not ok then
            ngx.shared.masking_config:set("initialized", "false")
            ngx.shared.masking_config:set("error", tostring(err))
        end
    }
    
    # Worker initialization for per-worker optimizations
    init_worker_by_lua_block {
        local ok, err = pcall(function()
            -- Initialize worker-specific data
            ngx.log(ngx.ERR, "[MASKING-PLUGIN] Worker " .. ngx.worker.id() .. " initialized")
        end)
        
        if not ok then
            ngx.log(ngx.ERR, "[MASKING-PLUGIN] Worker initialization failed: " .. tostring(err))
        end
    }
    
    # Upstream configuration for Dify
    upstream dify_backend {
        server 127.0.0.1:5001 max_fails=3 fail_timeout=30s;
        keepalive 32;
        keepalive_requests 1000;
        keepalive_timeout 60s;
    }
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=health:10m rate=1r/s;
    
    server {
        listen 80 default_server;
        listen [::]:80 default_server;
        server_name _;
        
        # Security headers
        add_header X-Frame-Options DENY always;
        add_header X-Content-Type-Options nosniff always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        
        # Health check endpoint (optimized)
        location = /masking/health {
            limit_req zone=health burst=5 nodelay;
            
            content_by_lua_block {
                local start_time = ngx.now()
                
                local ok, result = pcall(function()
                    local utils = require("utils")
                    local json = utils.json
                    
                    -- Get stats from shared dict
                    local initialized = ngx.shared.masking_config:get("initialized")
                    local version = ngx.shared.masking_config:get("version")
                    local patterns_loaded = ngx.shared.masking_config:get("patterns_loaded")
                    local plugin_start_time = ngx.shared.masking_config:get("start_time")
                    
                    local health = {
                        status = initialized == "true" and "healthy" or "degraded",
                        version = version or "2.1.0",
                        mode = "openresty",
                        timestamp = ngx.time(),
                        uptime = ngx.time() - (plugin_start_time or ngx.time()),
                        worker_id = ngx.worker.id(),
                        patterns_loaded = patterns_loaded or 0,
                        performance = {
                            response_time_ms = string.format("%.3f", (ngx.now() - start_time) * 1000)
                        },
                        nginx_version = ngx.var.nginx_version,
                        lua_version = _VERSION
                    }
                    
                    ngx.header.content_type = "application/json"
                    ngx.header["Cache-Control"] = "no-cache"
                    ngx.say(json.encode(health))
                end)
                
                if not ok then
                    ngx.status = 500
                    ngx.header.content_type = "text/plain"
                    ngx.say("Health check failed: " .. tostring(result))
                end
            }
        }
        
        # Performance test endpoint
        location = /masking/test {
            limit_req zone=api burst=10 nodelay;
            
            content_by_lua_block {
                local start_time = ngx.now()
                
                local ok, result = pcall(function()
                    local pattern_matcher = require("pattern_matcher")
                    local utils = require("utils")
                    local json = utils.json
                    
                    local pm = pattern_matcher.new()
                    local test_text = "Contact: admin@example.com, Server: 192.168.1.100, Public IP: 8.8.8.8, IPv6: 2001:db8::1, Company: Google, Domain: google.com, Host: www"
                    
                    local masked, processing_time = utils.measure_time(function()
                        return pm:mask_text(test_text)
                    end)
                    
                    local response = {
                        original = test_text,
                        masked = masked,
                        processing_time_ms = string.format("%.3f", processing_time),
                        mappings = pm:get_mappings(),
                        stats = pm:get_stats(),
                        timestamp = ngx.time()
                    }
                    
                    ngx.header.content_type = "application/json"
                    ngx.say(json.encode(response))
                end)
                
                if not ok then
                    ngx.status = 500
                    ngx.header.content_type = "text/plain"
                    ngx.say("Test failed: " .. tostring(result))
                end
            }
        }
        
        # Debug endpoint
        location = /masking/debug {
            limit_req zone=api burst=5 nodelay;
            
            content_by_lua_block {
                local ok, result = pcall(function()
                    local utils = require("utils")
                    local json = utils.json
                    
                    local debug_info = {
                        nginx_version = ngx.var.nginx_version,
                        lua_version = _VERSION,
                        worker_id = ngx.worker.id(),
                        worker_count = ngx.worker.count(),
                        time_iso8601 = ngx.var.time_iso8601,
                        request_uri = ngx.var.request_uri,
                        remote_addr = ngx.var.remote_addr,
                        shared_dicts = {
                            masking_mappings = {
                                size = ngx.shared.masking_mappings:capacity(),
                                used = ngx.shared.masking_mappings:free_space()
                            },
                            masking_stats = {
                                size = ngx.shared.masking_stats:capacity(),
                                used = ngx.shared.masking_stats:free_space()
                            }
                        },
                        config = {
                            initialized = ngx.shared.masking_config:get("initialized"),
                            version = ngx.shared.masking_config:get("version"),
                            patterns_loaded = ngx.shared.masking_config:get("patterns_loaded")
                        }
                    }
                    
                    ngx.header.content_type = "application/json"
                    ngx.say(json.encode(debug_info))
                end)
                
                if not ok then
                    ngx.status = 500
                    ngx.header.content_type = "text/plain"
                    ngx.say("Debug failed: " .. tostring(result))
                end
            }
        }
        
        # Main proxy with masking
        location / {
            limit_req zone=api burst=20 nodelay;
            
            # Request processing
            access_by_lua_block {
                local ok, err = pcall(function()
                    local masking_plugin = require("masking_plugin")
                    local utils = require("utils")
                    
                    -- Initialize plugin for this request
                    local plugin = masking_plugin.new()
                    
                    -- Store plugin instance in ngx.ctx for use in other phases
                    ngx.ctx.masking_plugin = plugin
                    
                    utils.log("DEBUG", "Request processing started for: " .. ngx.var.request_uri)
                end)
                
                if not ok then
                    ngx.log(ngx.ERR, "[MASKING-PLUGIN] Access phase error: " .. tostring(err))
                end
            }
            
            # Proxy configuration
            proxy_pass http://dify_backend;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # Buffering
            proxy_buffering off;
            proxy_cache off;
            proxy_request_buffering off;
        }
        
        # Error pages
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;
        
        location = /50x.html {
            root /usr/share/nginx/html;
        }
    }
}
