# Sample Nginx configuration for lua-masking-plugin
# Place this in your nginx.conf or include it from your main configuration

# Load Lua modules path
lua_package_path "/path/to/nginx-lua-masking/lib/?.lua;;";

# Initialize plugin at startup
init_by_lua_block {
    -- Load the masking plugin
    local masking_plugin = require("masking_plugin")
    
    -- Load configuration
    local config_file = io.open("/path/to/nginx-lua-masking/config/default.json", "r")
    local config_json = config_file:read("*all")
    config_file:close()
    
    local cjson = require("cjson")
    local config = cjson.decode(config_json)
    
    -- Initialize global plugin instance
    _G.masking_plugin_instance = masking_plugin.new(config)
    
    if not _G.masking_plugin_instance then
        ngx.log(ngx.ERR, "Failed to initialize masking plugin")
    else
        ngx.log(ngx.INFO, "Masking plugin initialized successfully")
    end
}

# Periodic cleanup task
init_worker_by_lua_block {
    local function cleanup_task()
        if _G.masking_plugin_instance then
            local masking_plugin = require("masking_plugin")
            masking_plugin.global_cleanup(3600)  -- Cleanup mappings older than 1 hour
        end
    end
    
    -- Schedule cleanup every 5 minutes
    local ok, err = ngx.timer.every(300, cleanup_task)
    if not ok then
        ngx.log(ngx.ERR, "Failed to create cleanup timer: ", err)
    end
}

server {
    listen 80;
    server_name example.com;
    
    # Enable request body reading
    client_max_body_size 10m;
    client_body_buffer_size 128k;
    
    location /api/ {
        # Process request body (masking)
        access_by_lua_block {
            if not _G.masking_plugin_instance then
                ngx.log(ngx.ERR, "Masking plugin not initialized")
                return
            end
            
            -- Read request body
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            
            if body then
                local content_type = ngx.req.get_headers()["content-type"]
                local processed_body, modified = _G.masking_plugin_instance:process_request(body, content_type, ngx.req.get_headers())
                
                if modified then
                    -- Set the modified body
                    ngx.req.set_body_data(processed_body)
                    ngx.log(ngx.INFO, "Request body masked")
                end
            end
        }
        
        # Proxy to upstream
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Process response body (unmasking)
        body_filter_by_lua_block {
            if not _G.masking_plugin_instance then
                return
            end
            
            local chunk = ngx.arg[1]
            local eof = ngx.arg[2]
            
            if chunk then
                local content_type = ngx.header.content_type
                local processed_chunk = _G.masking_plugin_instance:process_response_chunk(chunk, content_type, eof)
                ngx.arg[1] = processed_chunk
            end
        }
    }
    
    # Health check endpoint
    location /health/masking {
        access_by_lua_block {
            if not _G.masking_plugin_instance then
                ngx.status = 503
                ngx.say('{"status": "error", "message": "Plugin not initialized"}')
                return ngx.exit(503)
            end
            
            local health = _G.masking_plugin_instance:health_check()
            local cjson = require("cjson")
            
            if health.status == "healthy" then
                ngx.status = 200
            elseif health.status == "warning" then
                ngx.status = 200
            else
                ngx.status = 503
            end
            
            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode(health))
            ngx.exit(ngx.status)
        }
    }
    
    # Statistics endpoint
    location /stats/masking {
        access_by_lua_block {
            if not _G.masking_plugin_instance then
                ngx.status = 503
                ngx.say('{"error": "Plugin not initialized"}')
                return ngx.exit(503)
            end
            
            local stats = _G.masking_plugin_instance:get_stats()
            local cjson = require("cjson")
            
            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode(stats))
            ngx.exit(200)
        }
    }
    
    # Plugin configuration endpoint (for runtime updates)
    location /config/masking {
        if ($request_method = GET) {
            access_by_lua_block {
                if not _G.masking_plugin_instance then
                    ngx.status = 503
                    ngx.say('{"error": "Plugin not initialized"}')
                    return ngx.exit(503)
                end
                
                local state = _G.masking_plugin_instance:export_state()
                local cjson = require("cjson")
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(state.config))
                ngx.exit(200)
            }
        }
        
        if ($request_method = POST) {
            access_by_lua_block {
                if not _G.masking_plugin_instance then
                    ngx.status = 503
                    ngx.say('{"error": "Plugin not initialized"}')
                    return ngx.exit(503)
                end
                
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.say('{"error": "No configuration provided"}')
                    return ngx.exit(400)
                end
                
                local cjson = require("cjson")
                local ok, new_config = pcall(cjson.decode, body)
                
                if not ok then
                    ngx.status = 400
                    ngx.say('{"error": "Invalid JSON configuration"}')
                    return ngx.exit(400)
                end
                
                local success, message = _G.masking_plugin_instance:update_config(new_config)
                
                if success then
                    ngx.status = 200
                    ngx.say('{"status": "success", "message": "' .. message .. '"}')
                else
                    ngx.status = 400
                    ngx.say('{"status": "error", "message": "' .. message .. '"}')
                end
                
                ngx.exit(ngx.status)
            }
        }
        
        return 405;  # Method not allowed
    }
}

# Upstream backend configuration
upstream backend {
    server 127.0.0.1:8080;
    # Add more backend servers as needed
    # server 127.0.0.1:8081;
    # server 127.0.0.1:8082;
}

# Error log configuration
error_log /var/log/nginx/masking_error.log info;
access_log /var/log/nginx/masking_access.log combined;

